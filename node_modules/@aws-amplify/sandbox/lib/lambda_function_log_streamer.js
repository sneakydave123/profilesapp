import { LogLevel } from '@aws-amplify/cli-core';
import { BackendIdentifierConversions, TagName, } from '@aws-amplify/platform-core';
import { DescribeStacksCommand, } from '@aws-sdk/client-cloudformation';
import { ListTagsCommand } from '@aws-sdk/client-lambda';
import { build as buildArn, parse as parseArn } from '@aws-sdk/util-arn-parser';
/**
 * Logs streamer for customer defined lambda functions in a sandbox.
 */
export class LambdaFunctionLogStreamer {
    lambda;
    cfnClient;
    logsMonitor;
    backendOutputClient;
    printer;
    enabled = false;
    /**
     * Creates an instance of LambdaFunctionLogStreamer
     */
    constructor(lambda, cfnClient, logsMonitor, backendOutputClient, printer) {
        this.lambda = lambda;
        this.cfnClient = cfnClient;
        this.logsMonitor = logsMonitor;
        this.backendOutputClient = backendOutputClient;
        this.printer = printer;
    }
    /**
     * Starts streaming logs in the given sandbox.
     * @param sandboxBackendId The sandbox backend identifier.
     * @param streamingOptions Options to configure the log streaming.
     */
    startStreamingLogs = async (sandboxBackendId, streamingOptions) => {
        if (streamingOptions?.enabled) {
            this.enabled = true;
        }
        else {
            return;
        }
        const backendOutput = await this.backendOutputClient.getOutput(sandboxBackendId);
        const definedFunctionsPayload = backendOutput['AWS::Amplify::Function']?.payload.definedFunctions;
        const deployedFunctionNames = definedFunctionsPayload
            ? JSON.parse(definedFunctionsPayload)
            : [];
        // To use list-tags API we need to convert function name to function Arn since it only accepts ARN as input
        const deployedFunctionNameToArnMap = await this.getFunctionArnFromNames(sandboxBackendId, deployedFunctionNames);
        if (!deployedFunctionNameToArnMap) {
            this.printer.log(`[Sandbox] Could not find any function in stack ${BackendIdentifierConversions.toStackName(sandboxBackendId)}. Streaming function logs will be turned off.`, LogLevel.DEBUG);
            return;
        }
        for (const entry of deployedFunctionNameToArnMap) {
            const listTagsResponse = await this.lambda.send(new ListTagsCommand({
                Resource: entry.arn,
            }));
            const friendlyFunctionName = listTagsResponse.Tags?.[TagName.FRIENDLY_NAME];
            if (!friendlyFunctionName) {
                this.printer.log(`[Sandbox] Could not find user defined name for lambda function ${entry.name}. Logs will not be streamed for this function.`, LogLevel.DEBUG);
                continue;
            }
            let shouldStreamLogs = false;
            if (streamingOptions.logsFilters) {
                for (const filter of streamingOptions.logsFilters) {
                    const pattern = new RegExp(filter);
                    if (pattern.test(friendlyFunctionName)) {
                        shouldStreamLogs = true;
                        this.printer.log(`[Sandbox] Logs for function ${friendlyFunctionName} will be streamed as it matched filter '${filter}'`, LogLevel.DEBUG);
                        break;
                    }
                }
            }
            else {
                // No logs filter, means we stream all logs
                this.printer.log(`[Sandbox] Logs for function ${friendlyFunctionName} will be streamed.`, LogLevel.DEBUG);
                shouldStreamLogs = true;
            }
            if (shouldStreamLogs) {
                this.logsMonitor?.addLogGroups(friendlyFunctionName, 
                // a CW log group is implicitly created for each lambda function with the lambda function's name
                `/aws/lambda/${entry.name}`);
            }
            else {
                this.printer.log(`[Sandbox] Skipping logs streaming for function ${friendlyFunctionName} since it did not match any filters. To stream logs for this function, ensure at least one of your logs-filters match this function name.`, LogLevel.DEBUG);
            }
        }
        // finally start listening
        this.logsMonitor?.activate(streamingOptions.logsOutFile);
    };
    stopStreamingLogs = () => {
        if (!this.enabled) {
            return;
        }
        this.printer.log(`[Sandbox] Streaming function logs will be paused during the deployment and will be resumed after the deployment is completed.`, LogLevel.DEBUG);
        this.logsMonitor?.pause();
    };
    /**
     * Adds functionArn for each function name provided. All the ARN components are taken from the root stack Arn
     * @param sandboxBackendId backendId for retrieving the root stack
     * @param functionNames Name of the functions for which ARN needs to be generated
     * @returns An object containing function name and ARN for each function name provided
     */
    getFunctionArnFromNames = async (sandboxBackendId, functionNames) => {
        if (!functionNames || functionNames.length === 0) {
            return;
        }
        const rootStackResources = await this.cfnClient.send(new DescribeStacksCommand({
            StackName: BackendIdentifierConversions.toStackName(sandboxBackendId),
        }));
        if (!rootStackResources?.Stacks?.[0]?.StackId) {
            this.printer.log(`[Sandbox] Cannot load root stack for Id ${BackendIdentifierConversions.toStackName(sandboxBackendId)}. Streaming function logs will be turned off.`, LogLevel.DEBUG);
            return;
        }
        const arnParts = parseArn(rootStackResources.Stacks[0].StackId);
        return functionNames.map((name) => {
            return {
                name,
                arn: buildArn({
                    resource: `function:${name}`,
                    service: 'lambda',
                    accountId: arnParts.accountId,
                    partition: arnParts.partition,
                    region: arnParts.region,
                }),
            };
        });
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhX2Z1bmN0aW9uX2xvZ19zdHJlYW1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9sYW1iZGFfZnVuY3Rpb25fbG9nX3N0cmVhbWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQVcsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRCxPQUFPLEVBQ0wsNEJBQTRCLEVBQzVCLE9BQU8sR0FDUixNQUFNLDRCQUE0QixDQUFDO0FBRXBDLE9BQU8sRUFFTCxxQkFBcUIsR0FDdEIsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN4QyxPQUFPLEVBQWdCLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXZFLE9BQU8sRUFBRSxLQUFLLElBQUksUUFBUSxFQUFFLEtBQUssSUFBSSxRQUFRLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUdoRjs7R0FFRztBQUNILE1BQU0sT0FBTyx5QkFBeUI7SUFNakI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQVRYLE9BQU8sR0FBWSxLQUFLLENBQUM7SUFDakM7O09BRUc7SUFDSCxZQUNtQixNQUFvQixFQUNwQixTQUErQixFQUMvQixXQUFzQyxFQUN0QyxtQkFBd0MsRUFDeEMsT0FBZ0I7UUFKaEIsV0FBTSxHQUFOLE1BQU0sQ0FBYztRQUNwQixjQUFTLEdBQVQsU0FBUyxDQUFzQjtRQUMvQixnQkFBVyxHQUFYLFdBQVcsQ0FBMkI7UUFDdEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxZQUFPLEdBQVAsT0FBTyxDQUFTO0lBQ2hDLENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsa0JBQWtCLEdBQUcsS0FBSyxFQUN4QixnQkFBbUMsRUFDbkMsZ0JBQWtELEVBQ2xELEVBQUU7UUFDRixJQUFJLGdCQUFnQixFQUFFLE9BQU8sRUFBRTtZQUM3QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztTQUNyQjthQUFNO1lBQ0wsT0FBTztTQUNSO1FBRUQsTUFBTSxhQUFh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UztvQkFDN0IsTUFBTSxFQUFFLFFBQVEsQ0FBQyxNQUFNO2lCQUN4QixDQUFDO2FBQ0gsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0NBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2dMZXZlbCwgUHJpbnRlciB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9jbGktY29yZSc7XG5pbXBvcnQgeyBCYWNrZW5kT3V0cHV0Q2xpZW50IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2RlcGxveWVkLWJhY2tlbmQtY2xpZW50JztcbmltcG9ydCB7XG4gIEJhY2tlbmRJZGVudGlmaWVyQ29udmVyc2lvbnMsXG4gIFRhZ05hbWUsXG59IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbGF0Zm9ybS1jb3JlJztcbmltcG9ydCB7IEJhY2tlbmRJZGVudGlmaWVyLCBCYWNrZW5kT3V0cHV0IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQge1xuICBDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgRGVzY3JpYmVTdGFja3NDb21tYW5kLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgTGFtYmRhQ2xpZW50LCBMaXN0VGFnc0NvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtbGFtYmRhJztcbmltcG9ydCB7IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IgfSBmcm9tICcuL2Nsb3Vkd2F0Y2hfbG9nc19tb25pdG9yLmpzJztcbmltcG9ydCB7IGJ1aWxkIGFzIGJ1aWxkQXJuLCBwYXJzZSBhcyBwYXJzZUFybiB9IGZyb20gJ0Bhd3Mtc2RrL3V0aWwtYXJuLXBhcnNlcic7XG5pbXBvcnQgeyBTYW5kYm94RnVuY3Rpb25TdHJlYW1pbmdPcHRpb25zIH0gZnJvbSAnLi9zYW5kYm94LmpzJztcblxuLyoqXG4gKiBMb2dzIHN0cmVhbWVyIGZvciBjdXN0b21lciBkZWZpbmVkIGxhbWJkYSBmdW5jdGlvbnMgaW4gYSBzYW5kYm94LlxuICovXG5leHBvcnQgY2xhc3MgTGFtYmRhRnVuY3Rpb25Mb2dTdHJlYW1lciB7XG4gIHByaXZhdGUgZW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMYW1iZGFGdW5jdGlvbkxvZ1N0cmVhbWVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxhbWJkYTogTGFtYmRhQ2xpZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2ZuQ2xpZW50OiBDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxvZ3NNb25pdG9yOiBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFja2VuZE91dHB1dENsaWVudDogQmFja2VuZE91dHB1dENsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByaW50ZXI6IFByaW50ZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBTdGFydHMgc3RyZWFtaW5nIGxvZ3MgaW4gdGhlIGdpdmVuIHNhbmRib3guXG4gICAqIEBwYXJhbSBzYW5kYm94QmFja2VuZElkIFRoZSBzYW5kYm94IGJhY2tlbmQgaWRlbnRpZmllci5cbiAgICogQHBhcmFtIHN0cmVhbWluZ09wdGlvbnMgT3B0aW9ucyB0byBjb25maWd1cmUgdGhlIGxvZyBzdHJlYW1pbmcuXG4gICAqL1xuICBzdGFydFN0cmVhbWluZ0xvZ3MgPSBhc3luYyAoXG4gICAgc2FuZGJveEJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgc3RyZWFtaW5nT3B0aW9ucz86IFNhbmRib3hGdW5jdGlvblN0cmVhbWluZ09wdGlvbnNcbiAgKSA9PiB7XG4gICAgaWYgKHN0cmVhbWluZ09wdGlvbnM/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBiYWNrZW5kT3V0cHV0OiBCYWNrZW5kT3V0cHV0ID1cbiAgICAgIGF3YWl0IHRoaXMuYmFja2VuZE91dHB1dENsaWVudC5nZXRPdXRwdXQoc2FuZGJveEJhY2tlbmRJZCk7XG5cbiAgICBjb25zdCBkZWZpbmVkRnVuY3Rpb25zUGF5bG9hZCA9XG4gICAgICBiYWNrZW5kT3V0cHV0WydBV1M6OkFtcGxpZnk6OkZ1bmN0aW9uJ10/LnBheWxvYWQuZGVmaW5lZEZ1bmN0aW9ucztcbiAgICBjb25zdCBkZXBsb3llZEZ1bmN0aW9uTmFtZXMgPSBkZWZpbmVkRnVuY3Rpb25zUGF5bG9hZFxuICAgICAgPyAoSlNPTi5wYXJzZShkZWZpbmVkRnVuY3Rpb25zUGF5bG9hZCkgYXMgc3RyaW5nW10pXG4gICAgICA6IFtdO1xuXG4gICAgLy8gVG8gdXNlIGxpc3QtdGFncyBBUEkgd2UgbmVlZCB0byBjb252ZXJ0IGZ1bmN0aW9uIG5hbWUgdG8gZnVuY3Rpb24gQXJuIHNpbmNlIGl0IG9ubHkgYWNjZXB0cyBBUk4gYXMgaW5wdXRcbiAgICBjb25zdCBkZXBsb3llZEZ1bmN0aW9uTmFtZVRvQXJuTWFwID0gYXdhaXQgdGhpcy5nZXRGdW5jdGlvbkFybkZyb21OYW1lcyhcbiAgICAgIHNhbmRib3hCYWNrZW5kSWQsXG4gICAgICBkZXBsb3llZEZ1bmN0aW9uTmFtZXNcbiAgICApO1xuXG4gICAgaWYgKCFkZXBsb3llZEZ1bmN0aW9uTmFtZVRvQXJuTWFwKSB7XG4gICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICBgW1NhbmRib3hdIENvdWxkIG5vdCBmaW5kIGFueSBmdW5jdGlvbiBpbiBzdGFjayAke0JhY2tlbmRJZGVudGlmaWVyQ29udmVyc2lvbnMudG9TdGFja05hbWUoXG4gICAgICAgICAgc2FuZGJveEJhY2tlbmRJZFxuICAgICAgICApfS4gU3RyZWFtaW5nIGZ1bmN0aW9uIGxvZ3Mgd2lsbCBiZSB0dXJuZWQgb2ZmLmAsXG4gICAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZGVwbG95ZWRGdW5jdGlvbk5hbWVUb0Fybk1hcCkge1xuICAgICAgY29uc3QgbGlzdFRhZ3NSZXNwb25zZSA9IGF3YWl0IHRoaXMubGFtYmRhLnNlbmQoXG4gICAgICAgIG5ldyBMaXN0VGFnc0NvbW1hbmQoe1xuICAgICAgICAgIFJlc291cmNlOiBlbnRyeS5hcm4sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgY29uc3QgZnJpZW5kbHlGdW5jdGlvbk5hbWUgPVxuICAgICAgICBsaXN0VGFnc1Jlc3BvbnNlLlRhZ3M/LltUYWdOYW1lLkZSSUVORExZX05BTUVdO1xuICAgICAgaWYgKCFmcmllbmRseUZ1bmN0aW9uTmFtZSkge1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgIGBbU2FuZGJveF0gQ291bGQgbm90IGZpbmQgdXNlciBkZWZpbmVkIG5hbWUgZm9yIGxhbWJkYSBmdW5jdGlvbiAke2VudHJ5Lm5hbWV9LiBMb2dzIHdpbGwgbm90IGJlIHN0cmVhbWVkIGZvciB0aGlzIGZ1bmN0aW9uLmAsXG4gICAgICAgICAgTG9nTGV2ZWwuREVCVUdcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBzaG91bGRTdHJlYW1Mb2dzID0gZmFsc2U7XG4gICAgICBpZiAoc3RyZWFtaW5nT3B0aW9ucy5sb2dzRmlsdGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBzdHJlYW1pbmdPcHRpb25zLmxvZ3NGaWx0ZXJzKSB7XG4gICAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoZmlsdGVyKTtcbiAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGZyaWVuZGx5RnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgc2hvdWxkU3RyZWFtTG9ncyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgICAgICBgW1NhbmRib3hdIExvZ3MgZm9yIGZ1bmN0aW9uICR7ZnJpZW5kbHlGdW5jdGlvbk5hbWV9IHdpbGwgYmUgc3RyZWFtZWQgYXMgaXQgbWF0Y2hlZCBmaWx0ZXIgJyR7ZmlsdGVyfSdgLFxuICAgICAgICAgICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gbG9ncyBmaWx0ZXIsIG1lYW5zIHdlIHN0cmVhbSBhbGwgbG9nc1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgIGBbU2FuZGJveF0gTG9ncyBmb3IgZnVuY3Rpb24gJHtmcmllbmRseUZ1bmN0aW9uTmFtZX0gd2lsbCBiZSBzdHJlYW1lZC5gLFxuICAgICAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgICAgICk7XG4gICAgICAgIHNob3VsZFN0cmVhbUxvZ3MgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkU3RyZWFtTG9ncykge1xuICAgICAgICB0aGlzLmxvZ3NNb25pdG9yPy5hZGRMb2dHcm91cHMoXG4gICAgICAgICAgZnJpZW5kbHlGdW5jdGlvbk5hbWUsXG4gICAgICAgICAgLy8gYSBDVyBsb2cgZ3JvdXAgaXMgaW1wbGljaXRseSBjcmVhdGVkIGZvciBlYWNoIGxhbWJkYSBmdW5jdGlvbiB3aXRoIHRoZSBsYW1iZGEgZnVuY3Rpb24ncyBuYW1lXG4gICAgICAgICAgYC9hd3MvbGFtYmRhLyR7ZW50cnkubmFtZX1gXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICAgIGBbU2FuZGJveF0gU2tpcHBpbmcgbG9ncyBzdHJlYW1pbmcgZm9yIGZ1bmN0aW9uICR7ZnJpZW5kbHlGdW5jdGlvbk5hbWV9IHNpbmNlIGl0IGRpZCBub3QgbWF0Y2ggYW55IGZpbHRlcnMuIFRvIHN0cmVhbSBsb2dzIGZvciB0aGlzIGZ1bmN0aW9uLCBlbnN1cmUgYXQgbGVhc3Qgb25lIG9mIHlvdXIgbG9ncy1maWx0ZXJzIG1hdGNoIHRoaXMgZnVuY3Rpb24gbmFtZS5gLFxuICAgICAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWxseSBzdGFydCBsaXN0ZW5pbmdcbiAgICB0aGlzLmxvZ3NNb25pdG9yPy5hY3RpdmF0ZShzdHJlYW1pbmdPcHRpb25zLmxvZ3NPdXRGaWxlKTtcbiAgfTtcblxuICBzdG9wU3RyZWFtaW5nTG9ncyA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgYFtTYW5kYm94XSBTdHJlYW1pbmcgZnVuY3Rpb24gbG9ncyB3aWxsIGJlIHBhdXNlZCBkdXJpbmcgdGhlIGRlcGxveW1lbnQgYW5kIHdpbGwgYmUgcmVzdW1lZCBhZnRlciB0aGUgZGVwbG95bWVudCBpcyBjb21wbGV0ZWQuYCxcbiAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgKTtcbiAgICB0aGlzLmxvZ3NNb25pdG9yPy5wYXVzZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGZ1bmN0aW9uQXJuIGZvciBlYWNoIGZ1bmN0aW9uIG5hbWUgcHJvdmlkZWQuIEFsbCB0aGUgQVJOIGNvbXBvbmVudHMgYXJlIHRha2VuIGZyb20gdGhlIHJvb3Qgc3RhY2sgQXJuXG4gICAqIEBwYXJhbSBzYW5kYm94QmFja2VuZElkIGJhY2tlbmRJZCBmb3IgcmV0cmlldmluZyB0aGUgcm9vdCBzdGFja1xuICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lcyBOYW1lIG9mIHRoZSBmdW5jdGlvbnMgZm9yIHdoaWNoIEFSTiBuZWVkcyB0byBiZSBnZW5lcmF0ZWRcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb24gbmFtZSBhbmQgQVJOIGZvciBlYWNoIGZ1bmN0aW9uIG5hbWUgcHJvdmlkZWRcbiAgICovXG4gIHByaXZhdGUgZ2V0RnVuY3Rpb25Bcm5Gcm9tTmFtZXMgPSBhc3luYyAoXG4gICAgc2FuZGJveEJhY2tlbmRJZDogQmFja2VuZElkZW50aWZpZXIsXG4gICAgZnVuY3Rpb25OYW1lcz86IHN0cmluZ1tdXG4gICkgPT4ge1xuICAgIGlmICghZnVuY3Rpb25OYW1lcyB8fCBmdW5jdGlvbk5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3RTdGFja1Jlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuQ2xpZW50LnNlbmQoXG4gICAgICBuZXcgRGVzY3JpYmVTdGFja3NDb21tYW5kKHtcbiAgICAgICAgU3RhY2tOYW1lOiBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLnRvU3RhY2tOYW1lKHNhbmRib3hCYWNrZW5kSWQpLFxuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKCFyb290U3RhY2tSZXNvdXJjZXM/LlN0YWNrcz8uWzBdPy5TdGFja0lkKSB7XG4gICAgICB0aGlzLnByaW50ZXIubG9nKFxuICAgICAgICBgW1NhbmRib3hdIENhbm5vdCBsb2FkIHJvb3Qgc3RhY2sgZm9yIElkICR7QmFja2VuZElkZW50aWZpZXJDb252ZXJzaW9ucy50b1N0YWNrTmFtZShcbiAgICAgICAgICBzYW5kYm94QmFja2VuZElkXG4gICAgICAgICl9LiBTdHJlYW1pbmcgZnVuY3Rpb24gbG9ncyB3aWxsIGJlIHR1cm5lZCBvZmYuYCxcbiAgICAgICAgTG9nTGV2ZWwuREVCVUdcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXJuUGFydHMgPSBwYXJzZUFybihyb290U3RhY2tSZXNvdXJjZXMuU3RhY2tzWzBdLlN0YWNrSWQpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uTmFtZXMubWFwKChuYW1lKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBhcm46IGJ1aWxkQXJuKHtcbiAgICAgICAgICByZXNvdXJjZTogYGZ1bmN0aW9uOiR7bmFtZX1gLFxuICAgICAgICAgIHNlcnZpY2U6ICdsYW1iZGEnLFxuICAgICAgICAgIGFjY291bnRJZDogYXJuUGFydHMuYWNjb3VudElkLFxuICAgICAgICAgIHBhcnRpdGlvbjogYXJuUGFydHMucGFydGl0aW9uLFxuICAgICAgICAgIHJlZ2lvbjogYXJuUGFydHMucmVnaW9uLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG4iXX0=