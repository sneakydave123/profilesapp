import fs from 'fs';
import { staticEnvironmentVariables } from './static_env_types.js';
import path from 'path';
import { EOL } from 'os';
/**
 * Generates a typed process.env shim for environment variables
 */
export class FunctionEnvironmentTypeGenerator {
    functionName;
    header = '// This file is auto-generated by Amplify. Edits will be overwritten.';
    // The variable gets updated when the fully typed file is updated.
    envAssignment = 'export const env = process.env';
    typeDefFilePath;
    indentation = '  ';
    /**
     * Initialize typed process.env shim file name and location
     */
    constructor(functionName) {
        this.functionName = functionName;
        this.typeDefFilePath = `${process.cwd()}/.amplify/generated/env/${this.functionName}.ts`;
    }
    /**
     * Generate a typed process.env shim
     */
    generateTypedProcessEnvShim(amplifyBackendEnvVars) {
        const lambdaEnvVarTypeName = 'LambdaProvidedEnvVars';
        const amplifyBackendEnvVarTypeName = 'AmplifyBackendEnvVars';
        const declarations = [];
        // Add Lambda runtime environment variables to the typed shim
        declarations.push(`/** Lambda runtime environment variables, see https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime */`);
        declarations.push(`type ${lambdaEnvVarTypeName} = {`);
        for (const key in staticEnvironmentVariables) {
            const comment = `${this.indentation}/** ${staticEnvironmentVariables[key]} */`;
            const declaration = `${this.indentation}${key}: string;`;
            declarations.push(comment + EOL + declaration + EOL);
        }
        declarations.push(`};${EOL}`);
        /**
         * Add Amplify backend environment variables to the typed shim which can be either of the following:
         * 1. Defined by the customer passing env vars to the environment parameter for defineFunction
         * 2. Defined by resource access mechanisms
         */
        declarations.push(`/** Amplify backend environment variables available at runtime, this includes environment variables defined in \`defineFunction\` and by cross resource mechanisms */`);
        declarations.push(`type ${amplifyBackendEnvVarTypeName} = {`);
        amplifyBackendEnvVars.forEach((envName) => {
            const declaration = `${this.indentation}${envName}: string;`;
            declarations.push(declaration);
        });
        declarations.push(`};${EOL}`);
        const content = `${this.header}${EOL}${this.envAssignment} as ${lambdaEnvVarTypeName} & ${amplifyBackendEnvVarTypeName};${EOL}${EOL}${declarations.join(EOL)}`;
        this.writeShimFile(content);
    }
    /**
     * Generate an any-typed process.env shim if doesn't exist
     */
    generateProcessEnvShim = () => {
        // Create an "any" typed variable while creating the initial file to keep TSC happy
        // in case the synth fails and doesn't generate the typed shim.
        // We run TSC regardless after the synth to show more relevant TS errors and this prevents showing env related type errors.
        const content = `${this.header}${EOL}${this.envAssignment} as any;`;
        this.writeShimFile(content);
    };
    writeShimFile = (content) => {
        const typeDefFileDirname = path.dirname(this.typeDefFilePath);
        if (!fs.existsSync(typeDefFileDirname)) {
            fs.mkdirSync(typeDefFileDirname, { recursive: true });
        }
        fs.writeFileSync(this.typeDefFilePath, content);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25fZW52X3R5cGVfZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Z1bmN0aW9uX2Vudl90eXBlX2dlbmVyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkUsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFFekI7O0dBRUc7QUFDSCxNQUFNLE9BQU8sZ0NBQWdDO0lBY2Q7SUFiWixNQUFNLEdBQ3JCLHVFQUF1RSxDQUFDO0lBRTFFLGtFQUFrRTtJQUNqRCxhQUFhLEdBQUcsZ0NBQWdDLENBQUM7SUFFMUQsZUFBZSxDQUFTO0lBRXhCLFdBQVcsR0FBVyxJQUFJLENBQUM7SUFFbkM7O09BRUc7SUFDSCxZQUE2QixZQUFvQjtRQUFwQixpQkFBWSxHQUFaLFlBQVksQ0FBUTtRQUMvQyxJQUFJLENBQUMsZUFBZSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSwyQkFDckMsSUFBSSxDQUFDLFlBQ1AsS0FBSyxDQUFDO0lBQ1IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsMkJBQTJCLENBQUMscUJBQStCO1FBQ3pELE1BQU0sb0JBQW9CLEdBQUcsdUJBQXVCLENBQUM7UUFDckQsTUFBTSw0QkFBNEIsR0FBRyx1QkFBdUIsQ0FBQztRQUU3RCxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7UUFFeEIsNkRBQTZEO1FBQzdELFlBQVksQ0FBQyxJQUFJLENBQ2Ysd0pBQXdKLENBQ3pKLENBQUM7UUFDRixZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsb0JBQW9CLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELEtBQUssTUFBTSxHQUFHLElBQUksMEJBQTBCLEVBQUU7WUFDNUMsTUFBTSxPQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxPQUFPLDBCQUEwQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7WUFDL0UsTUFBTSxXQUFXLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLEdBQUcsV0FBVyxDQUFDO1lBRXpELFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRyxXQUFXLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDdEQ7UUFDRCxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztRQUU5Qjs7OztXQUlHO1FBQ0gsWUFBWSxDQUFDLElBQUksQ0FDZix1S0FBdUssQ0FDeEssQ0FBQztRQUNGLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSw0QkFBNEIsTUFBTSxDQUFDLENBQUM7UUFDOUQscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDeEMsTUFBTSxXQUFXLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLE9BQU8sV0FBVyxDQUFDO1lBRTdELFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDakMsQ0FBQyxDQUFDLENBQUM7UUFDSCxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztRQUU5QixNQUFNLE9BQU8sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxHQUNsQyxJQUFJLENBQUMsYUFDUCxPQUFPLG9CQUFvQixNQUFNLDRCQUE0QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FDNUYsR0FBRyxDQUNKLEVBQUUsQ0FBQztRQUVKLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsc0JBQXNCLEdBQUcsR0FBRyxFQUFFO1FBQzVCLG1GQUFtRjtRQUNuRiwrREFBK0Q7UUFDL0QsMkhBQTJIO1FBQzNILE1BQU0sT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLGFBQWEsVUFBVSxDQUFDO1FBQ3BFLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUIsQ0FBQyxDQUFDO0lBRU0sYUFBYSxHQUFHLENBQUMsT0FBZSxFQUFFLEVBQUU7UUFDMUMsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUU5RCxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ3RDLEVBQUUsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUN2RDtRQUVELEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBzdGF0aWNFbnZpcm9ubWVudFZhcmlhYmxlcyB9IGZyb20gJy4vc3RhdGljX2Vudl90eXBlcy5qcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0eXBlZCBwcm9jZXNzLmVudiBzaGltIGZvciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRW52aXJvbm1lbnRUeXBlR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBoZWFkZXIgPVxuICAgICcvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQW1wbGlmeS4gRWRpdHMgd2lsbCBiZSBvdmVyd3JpdHRlbi4nO1xuXG4gIC8vIFRoZSB2YXJpYWJsZSBnZXRzIHVwZGF0ZWQgd2hlbiB0aGUgZnVsbHkgdHlwZWQgZmlsZSBpcyB1cGRhdGVkLlxuICBwcml2YXRlIHJlYWRvbmx5IGVudkFzc2lnbm1lbnQgPSAnZXhwb3J0IGNvbnN0IGVudiA9IHByb2Nlc3MuZW52JztcblxuICBwcml2YXRlIHR5cGVEZWZGaWxlUGF0aDogc3RyaW5nO1xuXG4gIHByaXZhdGUgaW5kZW50YXRpb246IHN0cmluZyA9ICcgICc7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdHlwZWQgcHJvY2Vzcy5lbnYgc2hpbSBmaWxlIG5hbWUgYW5kIGxvY2F0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZ1bmN0aW9uTmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy50eXBlRGVmRmlsZVBhdGggPSBgJHtwcm9jZXNzLmN3ZCgpfS8uYW1wbGlmeS9nZW5lcmF0ZWQvZW52LyR7XG4gICAgICB0aGlzLmZ1bmN0aW9uTmFtZVxuICAgIH0udHNgO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHlwZWQgcHJvY2Vzcy5lbnYgc2hpbVxuICAgKi9cbiAgZ2VuZXJhdGVUeXBlZFByb2Nlc3NFbnZTaGltKGFtcGxpZnlCYWNrZW5kRW52VmFyczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBsYW1iZGFFbnZWYXJUeXBlTmFtZSA9ICdMYW1iZGFQcm92aWRlZEVudlZhcnMnO1xuICAgIGNvbnN0IGFtcGxpZnlCYWNrZW5kRW52VmFyVHlwZU5hbWUgPSAnQW1wbGlmeUJhY2tlbmRFbnZWYXJzJztcblxuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IFtdO1xuXG4gICAgLy8gQWRkIExhbWJkYSBydW50aW1lIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgdHlwZWQgc2hpbVxuICAgIGRlY2xhcmF0aW9ucy5wdXNoKFxuICAgICAgYC8qKiBMYW1iZGEgcnVudGltZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vbGFtYmRhL2xhdGVzdC9kZy9jb25maWd1cmF0aW9uLWVudnZhcnMuaHRtbCNjb25maWd1cmF0aW9uLWVudnZhcnMtcnVudGltZSAqL2BcbiAgICApO1xuICAgIGRlY2xhcmF0aW9ucy5wdXNoKGB0eXBlICR7bGFtYmRhRW52VmFyVHlwZU5hbWV9ID0ge2ApO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXRpY0Vudmlyb25tZW50VmFyaWFibGVzKSB7XG4gICAgICBjb25zdCBjb21tZW50ID0gYCR7dGhpcy5pbmRlbnRhdGlvbn0vKiogJHtzdGF0aWNFbnZpcm9ubWVudFZhcmlhYmxlc1trZXldfSAqL2A7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGAke3RoaXMuaW5kZW50YXRpb259JHtrZXl9OiBzdHJpbmc7YDtcblxuICAgICAgZGVjbGFyYXRpb25zLnB1c2goY29tbWVudCArIEVPTCArIGRlY2xhcmF0aW9uICsgRU9MKTtcbiAgICB9XG4gICAgZGVjbGFyYXRpb25zLnB1c2goYH07JHtFT0x9YCk7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgQW1wbGlmeSBiYWNrZW5kIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgdHlwZWQgc2hpbSB3aGljaCBjYW4gYmUgZWl0aGVyIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICogMS4gRGVmaW5lZCBieSB0aGUgY3VzdG9tZXIgcGFzc2luZyBlbnYgdmFycyB0byB0aGUgZW52aXJvbm1lbnQgcGFyYW1ldGVyIGZvciBkZWZpbmVGdW5jdGlvblxuICAgICAqIDIuIERlZmluZWQgYnkgcmVzb3VyY2UgYWNjZXNzIG1lY2hhbmlzbXNcbiAgICAgKi9cbiAgICBkZWNsYXJhdGlvbnMucHVzaChcbiAgICAgIGAvKiogQW1wbGlmeSBiYWNrZW5kIGVudmlyb25tZW50IHZhcmlhYmxlcyBhdmFpbGFibGUgYXQgcnVudGltZSwgdGhpcyBpbmNsdWRlcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZGVmaW5lZCBpbiBcXGBkZWZpbmVGdW5jdGlvblxcYCBhbmQgYnkgY3Jvc3MgcmVzb3VyY2UgbWVjaGFuaXNtcyAqL2BcbiAgICApO1xuICAgIGRlY2xhcmF0aW9ucy5wdXNoKGB0eXBlICR7YW1wbGlmeUJhY2tlbmRFbnZWYXJUeXBlTmFtZX0gPSB7YCk7XG4gICAgYW1wbGlmeUJhY2tlbmRFbnZWYXJzLmZvckVhY2goKGVudk5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gYCR7dGhpcy5pbmRlbnRhdGlvbn0ke2Vudk5hbWV9OiBzdHJpbmc7YDtcblxuICAgICAgZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgIH0pO1xuICAgIGRlY2xhcmF0aW9ucy5wdXNoKGB9OyR7RU9MfWApO1xuXG4gICAgY29uc3QgY29udGVudCA9IGAke3RoaXMuaGVhZGVyfSR7RU9MfSR7XG4gICAgICB0aGlzLmVudkFzc2lnbm1lbnRcbiAgICB9IGFzICR7bGFtYmRhRW52VmFyVHlwZU5hbWV9ICYgJHthbXBsaWZ5QmFja2VuZEVudlZhclR5cGVOYW1lfTske0VPTH0ke0VPTH0ke2RlY2xhcmF0aW9ucy5qb2luKFxuICAgICAgRU9MXG4gICAgKX1gO1xuXG4gICAgdGhpcy53cml0ZVNoaW1GaWxlKGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGFueS10eXBlZCBwcm9jZXNzLmVudiBzaGltIGlmIGRvZXNuJ3QgZXhpc3RcbiAgICovXG4gIGdlbmVyYXRlUHJvY2Vzc0VudlNoaW0gPSAoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGFuIFwiYW55XCIgdHlwZWQgdmFyaWFibGUgd2hpbGUgY3JlYXRpbmcgdGhlIGluaXRpYWwgZmlsZSB0byBrZWVwIFRTQyBoYXBweVxuICAgIC8vIGluIGNhc2UgdGhlIHN5bnRoIGZhaWxzIGFuZCBkb2Vzbid0IGdlbmVyYXRlIHRoZSB0eXBlZCBzaGltLlxuICAgIC8vIFdlIHJ1biBUU0MgcmVnYXJkbGVzcyBhZnRlciB0aGUgc3ludGggdG8gc2hvdyBtb3JlIHJlbGV2YW50IFRTIGVycm9ycyBhbmQgdGhpcyBwcmV2ZW50cyBzaG93aW5nIGVudiByZWxhdGVkIHR5cGUgZXJyb3JzLlxuICAgIGNvbnN0IGNvbnRlbnQgPSBgJHt0aGlzLmhlYWRlcn0ke0VPTH0ke3RoaXMuZW52QXNzaWdubWVudH0gYXMgYW55O2A7XG4gICAgdGhpcy53cml0ZVNoaW1GaWxlKGNvbnRlbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgd3JpdGVTaGltRmlsZSA9IChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB0eXBlRGVmRmlsZURpcm5hbWUgPSBwYXRoLmRpcm5hbWUodGhpcy50eXBlRGVmRmlsZVBhdGgpO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHR5cGVEZWZGaWxlRGlybmFtZSkpIHtcbiAgICAgIGZzLm1rZGlyU3luYyh0eXBlRGVmRmlsZURpcm5hbWUsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy50eXBlRGVmRmlsZVBhdGgsIGNvbnRlbnQpO1xuICB9O1xufVxuIl19